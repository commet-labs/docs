---
title: Product Catalog Business Logic
description: Dive into the pricing architecture, governance rules, and billing integrations that power the Commet product catalog.
---

import { Tabs, Tab } from 'fumadocs-ui/components/tabs'
import { Callout } from 'fumadocs-ui/components/callout'

# Business logic & design

This page connects the strategy behind the Product Catalog to the systems that execute it. Use it when you need to translate commercial ideas into catalog configuration or when you must explain pricing logic to stakeholders.

<Callout type="info">
Platform documentation aims at business operators. For SDKs, endpoints, and code samples head to the Developer Library.
</Callout>

## Accessing the product catalog

The product catalog is available through the **Products** section in your Commet platform. From here you can:

- **View all products**: Browse your complete product portfolio with SKUs, descriptions, and tax categories
- **Manage list prices**: Create and edit standard prices for each product across currencies and segments
- **Configure price variants**: Set up customer-specific pricing with discounts, markups, or custom terms
- **Link to agreements**: See which agreements reference specific prices or variants

## Why the catalog exists

The catalog solves pricing-complexity management for billing platforms that juggle multiple pricing models and customer-specific terms.

**Problems it eliminates**

- Custom code for every new price or promotion.
- Sales asking “What’s the official price?” vs. “What are we offering this customer?”
- Lack of analytics on discount adoption or premium pricing.
- No approval workflow for large enterprise concessions.
- Pricing updates blocked behind engineering queues.

**Business outcomes**

- Clear list price vs. customer price conversations.
- Accurate analytics for margins, discounts, and product performance.
- Negotiation playbooks that combine list tiers and approved variants.
- Automated governance that flags discounts beyond policy.
- Freedom to support any business model without code changes.

## Four pricing layers working together

Prices act as the core building blocks in Commet. Each price defines unit cost, pricing model, currency, billing frequency, and billing type. These prices can be reused across multiple customers, making catalog management efficient and scalable.

```
Products describe the services you sell:
├── API Platform → API access with rate limiting
├── Analytics Dashboard → Reporting and insights
├── Premium Support → 24/7 help with SLA
├── Data Storage → Scalable storage
└── AI Processing → Machine learning services
```

```
Product: API Platform
├── List Price: Starter → $50/month, 10K calls included
├── List Price: Professional → $200/month, 100K calls included
├── List Price: Enterprise → $500/month, 1M calls included
└── List Price: Pay-per-use → $0.10 per call, no minimum
```

```
List Price: Enterprise ($500/month)
├── Price Variant: Acme Corp → 20% discount = $400/month
├── Price Variant: MercadoLibre → $500/month, 2M calls included
├── Price Variant: Startup Beta → 50% discount = $250/month
└── Price Variant: Enterprise Plus → 10% markup = $550/month
```

```
Agreement: Acme Corp – Q1 2025
├── Item 1: API Platform → Enterprise Plan (20% variant)
├── Item 2: Analytics Dashboard → Professional Plan (list price)
├── Item 3: Premium Support → Custom price variant
└── Contract discount: 5% promo for Q1
```

Each layer keeps analytics intact and separates permanent configuration (variants) from temporary negotiation tools (agreement discounts).

### Price reusability and identification

Every price in the catalog has a unique `price_id` that serves as its identifier across the platform. This allows you to:

- **Reuse standard prices** across multiple customers without duplication
- **Track pricing changes** and maintain historical accuracy
- **Reference prices** consistently in agreements, invoices, and analytics
- **Create variants** from existing list prices while preserving the relationship

## Real-world catalogs

<Tabs items={['SaaS Ladder', 'Payments', 'AI & ML', 'Usage Metrics']}>
<Tab value="SaaS Ladder">
**Company**: DevTools Inc. – API development platform

1. Start with Free → Starter → Pro → Enterprise list prices.
2. Add-ons such as Analytics or Priority Support live as separate products.
3. Enterprise deals add price variants (20% off, extra seats).
4. The agreement bundles everything so billing can generate accurate invoices.
</Tab>
<Tab value="Payments">
**Company**: PayFlow – payment processor

- List prices capture standard, volume, and enterprise transaction fees.
- Price variants store negotiated percentage rates and minimum commitments.
- Additional products cover cross-border fees and chargeback insurance.
- Agreements combine multi-product bundles with volume-based approvals.
</Tab>
<Tab value="AI & ML">
**Company**: AIFlow – machine learning platform

- Products: compute hours, data scientist seats, model hosting.
- List prices mix on-demand, reserved, and spot usage offers.
- Variants track high-volume seat discounts and custom GPU bundles.
- Agreements apply temporary promos while variants manage long-term terms.
</Tab>
<Tab value="Usage Metrics">
**Understanding Usage-Based Pricing**

Usage metrics are the foundation of consumption-based pricing models. They track customer activity and convert it into billable units.

**How usage metrics work:**

1. **Define the metric**: Create a usage metric that tracks specific customer behavior (API calls, storage GB, compute hours, transactions processed).
2. **Send usage events**: Your application reports usage events to Commet in real-time or in batches.
3. **Aggregate consumption**: The billing engine aggregates usage data for each billing period.
4. **Apply pricing rules**: Your configured pricing model (linear, tiered, packaged) calculates the charge.
5. **Generate invoices**: Usage charges appear as line items with consumption details.

**Common usage metric examples:**

- **API Platforms**: API calls, requests per minute, data transfer GB
- **Infrastructure**: Compute hours, storage GB, bandwidth consumed
- **Communications**: SMS sent, phone minutes, email deliveries
- **AI/ML**: Model predictions, training hours, tokens processed
- **Payment Processing**: Transaction volume, payment count

**Pricing flexibility with usage metrics:**

Usage metrics can be combined with multiple pricing models:
- **Linear**: $0.10 per API call
- **Graduated tiers**: First 100K calls @ $0.10, next 400K @ $0.08, 500K+ @ $0.05
- **Volume tiers**: 0-100K @ $0.10, 100K+ @ $0.07 (customer pays only their tier rate)
- **Packaged**: $25 per 1,000 API calls
- **With included units**: First 10K calls free, then $0.10 per call
- **Credit burndown**: 50K API credits pack, 1 call = 5 credits

**TODO: Add usage metrics architecture diagram here showing: Usage Event → Aggregation → Pricing Model → Invoice Line Item**

**Best practices:**

- Name metrics clearly (e.g., "api-calls" not "metric-1")
- Choose appropriate aggregation (sum for API calls, max for concurrent users, unique for monthly active users)
- Set up alerts for unusual consumption patterns
- Provide customers with real-time usage dashboards
- Include usage details in invoices for transparency
</Tab>
</Tabs>

## Supported pricing models

| Model | Use case | Example |
| --- | --- | --- |
| **Fixed / subscription** | Predictable revenue, monthly or one-time fees. | $500/month platform fee, $2,500 onboarding |
| **Linear usage** | Pay-per-use with included units. | $0.10 per API call after 1,000 free calls |
| **Percentage-based** | Payments or revenue-sharing with safeguards. | 2.9% of transaction value with $0.30 min / $10 max |
| **Volume tiers** | Customer pays the rate of the tier they land in. | 0–100 units @ $1 + $20 flat, 101+ @ $0.75 + $50 |
| **Graduated tiers** | Progressive pricing like tax brackets. | First 100 GB @ $1, remaining @ $0.75 |
| **Packaged / stair-step** | Sell bundles of units. | $10 per 250 SMS sent |
| **Seat-based** | Billing tied to seat balances. | $50 per admin seat per month |
| **Minimum fees** | Guarantee baseline revenue. | $500 monthly minimum applied across usage prices |
| **Credit burndown** | Prepaid credits with rollover. | 2,500 credits pack, 10 credits per API call |

Code-friendly examples live in the developer docs, but the catalog UI exposes each model as configurable options.

## Governance rules

**When to create a product**

1. New value proposition or service line.
2. Different tax treatment.
3. Separate reporting needs.

**When to publish a list price**

1. New segment or market positioning.
2. Different commitment period or included units.
3. Switching pricing models (fixed vs. usage vs. tiers).

**When to use a price variant**

1. Customer-specific discount or currency.
2. Contracted unit changes or volume commitments.
3. Long-lived custom terms (not temporary promos).

**When to apply agreement discounts**

- Ramp-up phases, quarter promotions, or limited-time incentives.
- Layered on top of list prices and variants without breaking analytics.

## Multi-tenant flexibility

Each organization running on Commet can configure its own catalog:

- **Startup catalog**: a single core product with 4 plans, a couple of add-ons, minimal variants.
- **Enterprise catalog**: multiple products, professional services, dozens of variants with approvals, aggressive discount policies.

The catalog supports both extremes on the same infrastructure, keeping segmentation, discount policies, and reporting separate.

## Billing engine integration

All billing internals live in `billing-engine.md`, but here’s the high-level handshake:

- Products provide tax categories and descriptions for invoices.
- List prices act as the official baseline for negotiations.
- Price variants inject permanent customer customization.
- Pricing models (fixed, usage, seats, tiers) feed the billing calculator.
- Agreements combine everything and pass it downstream for invoice generation.

```typescript
function resolveFinalPricing(agreementItem: AgreementItem) {
  const listPrice = getListPrice(agreementItem.listPriceId);
  let finalAmount = listPrice.unitAmount;

  if (agreementItem.priceVariantId) {
    const variant = getPriceVariant(agreementItem.priceVariantId);
    finalAmount = applyVariantPricing(finalAmount, variant);
  }

  if (agreementItem.agreementDiscountType) {
    finalAmount = applyAgreementDiscount(finalAmount, agreementItem);
  }

  return { listPrice, finalAmount };
}
```

## Integration points with other modules

- **Usage module**: `price_variant.usage_metric_id → usage_metric.id` to track consumption.
- **Seats module**: `agreement_item.quantity_source = 'seat_balance'` pulls seat counts automatically.
- **Tax module**: `product.tax_category_id → tax_category.id` applies correct rates per product.
- **Customer module**: optional `price_variant.customer_id` to tie custom pricing to a specific account.

## End-to-end workflow

1. **Catalog setup**: define the product portfolio and assign tax categories.
2. **List price design**: product marketing publishes official pricing for each segment.
3. **Negotiation**: sales crafts price variants with approvals for custom deals.
4. **Contract signing**: agreements reference list prices, variants, and temporary discounts.
5. **Billing automation**: the billing engine executes the cascade and produces transparent receipts.

## Key success metrics

- Zero pricing errors in invoices.
- Full pricing-model coverage without engineering involvement.
- Sub-two-second pricing calculations even with complex tiers.
- No manual adjustments due to catalog limitations.

## Troubleshooting common scenarios

| Scenario | Root cause | Solution |
| --- | --- | --- |
| Invoice shows wrong price | Variant or agreement discount not applied | Verify `agreement_item` links correct `price_variant_id` and discount settings |
| Tax calculation missing | Product missing `tax_category_id` | Assign tax category to product before creating list prices |
| Pricing resolution timeout | Complex tier calculations with many variants | Optimize tier structure or cache frequently-used pricing paths |
| Discount approval bypassed | No policy enforcement on variant creation | Enable approval workflows in RevOps settings |