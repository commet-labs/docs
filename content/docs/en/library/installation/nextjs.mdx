---
title: Next.js Setup
description: Complete Next.js integration with Commet SDK
---

import { Steps, Step } from 'fumadocs-ui/components/steps'
import { Tabs, Tab } from 'fumadocs-ui/components/tabs'
import { Callout } from 'fumadocs-ui/components/callout'

# Next.js Setup

Complete guide for integrating Commet SDK with Next.js applications.

<Callout type="info">
**Requirements:** Next.js 13.4+ with App Router or Pages Router support.
</Callout>

<Steps>
<Step>

## Install the SDK

<Tabs items={['npm', 'pnpm', 'yarn']}>
<Tab value="npm">
```bash
npm install @commet/sdk
```
</Tab>
<Tab value="pnpm">
```bash
pnpm add @commet/sdk
```
</Tab>
<Tab value="yarn">
```bash
yarn add @commet/sdk
```
</Tab>
</Tabs>

</Step>

<Step>

## Configure Environment Variables

Add your API key to `.env.local`:

```bash title=".env.local"
COMMET_API_KEY=your_api_key_here
```

<Callout type="warn">
**Security:** Never expose your API key in client-side code. Always use server-side routes or API routes.
</Callout>

</Step>

<Step>

## Initialize the Client

Create a server-side client instance:

<Tabs items={['App Router', 'Pages Router']}>
<Tab value="App Router">
```typescript title="lib/commet.ts"
import { Commet } from '@commet/sdk'

export const commet = new Commet({
  apiKey: process.env.COMMET_API_KEY!,
})
```
</Tab>
<Tab value="Pages Router">
```typescript title="lib/commet.ts"
import { Commet } from '@commet/sdk'

export const commet = new Commet({
  apiKey: process.env.COMMET_API_KEY!,
})
```
</Tab>
</Tabs>

</Step>

<Step>

## Create API Routes

Set up billing endpoints in your application:

<Tabs items={['App Router', 'Pages Router']}>
<Tab value="App Router">
```typescript title="app/api/billing/usage/route.ts"
import { NextRequest, NextResponse } from 'next/server'
import { commet } from '@/lib/commet'

export async function POST(request: NextRequest) {
  try {
    const { eventType, customerId, quantity } = await request.json()
    
    const result = await commet.usage.create({
      eventType,
      customerId,
      quantity,
    })
    
    return NextResponse.json(result.data)
  } catch (error) {
    console.error('Usage tracking error:', error)
    return NextResponse.json(
      { error: 'Failed to track usage' },
      { status: 500 }
    )
  }
}
```
</Tab>
<Tab value="Pages Router">
```typescript title="pages/api/billing/usage.ts"
import type { NextApiRequest, NextApiResponse } from 'next'
import { commet } from '@/lib/commet'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' })
  }

  try {
    const { eventType, customerId, quantity } = req.body
    
    const result = await commet.usage.create({
      eventType,
      customerId,
      quantity,
    })
    
    res.status(200).json(result.data)
  } catch (error) {
    console.error('Usage tracking error:', error)
    res.status(500).json({ error: 'Failed to track usage' })
  }
}
```
</Tab>
</Tabs>

</Step>

<Step>

## Track Usage from Components

Create client-side functions to track usage:

<Tabs items={['App Router', 'Pages Router']}>
<Tab value="App Router">
```typescript title="app/actions/billing.ts"
'use server'

import { commet } from '@/lib/commet'

export async function trackUsage(
  eventType: string,
  customerId: string,
  quantity: number = 1
) {
  try {
    const result = await commet.usage.create({
      eventType,
      customerId,
      quantity,
    })
    
    return { success: true, data: result.data }
  } catch (error) {
    console.error('Usage tracking error:', error)
    return { success: false, error: 'Failed to track usage' }
  }
}
```

Use in components:
```typescript title="app/dashboard/page.tsx"
import { trackUsage } from '@/app/actions/billing'

export default function Dashboard() {
  const handleApiCall = async () => {
    // Your API logic here
    
    // Track usage
    await trackUsage('api_call', 'cus_A1b2C3d4E5f6G7h8I9j0K1l2')
  }

  return (
    <button onClick={handleApiCall}>
      Make API Call
    </button>
  )
}
```
</Tab>
<Tab value="Pages Router">
```typescript title="hooks/useBilling.ts"
import { useState } from 'react'

export function useBilling() {
  const [loading, setLoading] = useState(false)

  const trackUsage = async (
    eventType: string,
    customerId: string,
    quantity: number = 1
  ) => {
    setLoading(true)
    
    try {
      const response = await fetch('/api/billing/usage', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ eventType, customerId, quantity }),
      })
      
      if (!response.ok) throw new Error('Failed to track usage')
      
      const data = await response.json()
      return { success: true, data }
    } catch (error) {
      console.error('Usage tracking error:', error)
      return { success: false, error: 'Failed to track usage' }
    } finally {
      setLoading(false)
    }
  }

  return { trackUsage, loading }
}
```

Use in components:
```typescript title="components/Dashboard.tsx"
import { useBilling } from '@/hooks/useBilling'

export default function Dashboard() {
  const { trackUsage, loading } = useBilling()

  const handleApiCall = async () => {
    // Your API logic here
    
    // Track usage
    await trackUsage('api_call', 'cus_A1b2C3d4E5f6G7h8I9j0K1l2')
  }

  return (
    <button onClick={handleApiCall} disabled={loading}>
      {loading ? 'Processing...' : 'Make API Call'}
    </button>
  )
}
```
</Tab>
</Tabs>

</Step>
</Steps>

## Advanced Integration

### Middleware Integration

Track usage automatically with Next.js middleware:

```typescript title="middleware.ts"
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
import { commet } from '@/lib/commet'

export async function middleware(request: NextRequest) {
  // Only track API routes
  if (request.nextUrl.pathname.startsWith('/api/')) {
    const customerId = request.headers.get('x-customer-id')
    
    if (customerId) {
      // Track usage asynchronously
      commet.usage.create({
        eventType: 'api_call',
        customerId,
        quantity: 1,
        metadata: {
          endpoint: request.nextUrl.pathname,
          method: request.method,
        }
      }).catch(console.error)
    }
  }

  return NextResponse.next()
}

export const config = {
  matcher: '/api/:path*',
}
```

### Server Components

Use Commet SDK directly in Server Components:

```typescript title="app/billing/page.tsx"
import { commet } from '@/lib/commet'

export default async function BillingPage({
  searchParams,
}: {
  searchParams: { customerId: string }
}) {
  const usage = await commet.usage.list({
    customerId: searchParams.customerId,
    limit: 10,
  })

  return (
    <div>
      <h1>Usage History</h1>
      {usage.data.map(event => (
        <div key={event.id}>
          {event.eventType}: {event.quantity}
        </div>
      ))}
    </div>
  )
}
```

### Error Boundaries

Handle billing errors gracefully:

```typescript title="components/BillingErrorBoundary.tsx"
'use client'

import { Component, ReactNode } from 'react'

interface Props {
  children: ReactNode
}

interface State {
  hasError: boolean
}

export class BillingErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props)
    this.state = { hasError: false }
  }

  static getDerivedStateFromError(): State {
    return { hasError: true }
  }

  componentDidCatch(error: Error) {
    console.error('Billing error:', error)
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="p-4 border border-red-200 rounded">
          <h3>Billing Error</h3>
          <p>Usage tracking temporarily unavailable.</p>
        </div>
      )
    }

    return this.props.children
  }
}
```

## TypeScript Configuration

Enhance type safety with custom types:

```typescript title="types/billing.ts"
export interface UsageEvent {
  eventType: string
  customerId: string
  quantity: number
  metadata?: Record<string, any>
}

export interface SeatUpdate {
  customerId: string
  seatType: string
  quantity: number
}
```

## Best Practices

### Environment Management

Use different API keys for different environments:

```bash title=".env.local"
# Development
COMMET_API_KEY=sk_test_...

# Production (in deployment)
COMMET_API_KEY=sk_live_...
```

### Error Handling

Implement comprehensive error handling:

```typescript
try {
  await commet.usage.create({
    eventType: 'api_call',
    customerId: 'cus_A1b2C3d4E5f6G7h8I9j0K1l2',
    quantity: 1,
  })
} catch (error) {
  // Log for debugging
  console.error('Billing error:', error)
  
  // Don't block user experience
  // Continue with application flow
}
```

### Performance

Use async tracking to avoid blocking requests:

```typescript
// ✅ Non-blocking
commet.usage.create({
  eventType: 'api_call',
  customerId: 'cus_1234567890',
  quantity: 1,
}).catch(console.error)

// ❌ Blocking
await commet.usage.create({
  eventType: 'api_call',
  customerId: 'cus_1234567890',
  quantity: 1,
})
```

## What's next?

<div className="grid grid-cols-1 md:grid-cols-2 gap-4">
  <div className="border rounded-lg p-4">
    <h3 className="font-semibold mt-0">Usage Events</h3>
    <p className="text-sm text-muted-foreground">Start tracking customer usage</p>
    <p className="text-sm">[Track usage →](/library/features/usage-events)</p>
  </div>
  
  <div className="border rounded-lg p-4">
    <h3 className="font-semibold mt-0">Error Handling</h3>
    <p className="text-sm text-muted-foreground">Robust error handling patterns</p>
    <p className="text-sm">[Handle errors →](/library/core-concepts/error-handling)</p>
  </div>
</div>
